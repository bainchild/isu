local assert=assert;local a=typeof or type;local b=coroutine.running;local unpack=table.unpack or unpack;local next=next;local c=getmetatable;local d=setmetatable;local e=Instance and Instance.new;local f=game and game:GetService("TweenService")local g=game.Destroying.Connect;local h=g(game.Destroying,function()end).Disconnect;local i={}local j={__mode='k'}local k={__mode='v'}local l={__mode='kv'}local m=d({},j)local function n(o)return d({v=o},k)end;local function p(q,r)local s={}for t,u in next,q do local v,w=t,u;if a(t)=='table'and r then v=p(t,r)end;if a(u)=='table'and r then w=p(u,r)end;s[v]=w end;return s end;local function x()return{stk={},coro=d({},l),rst=function(y)y.coro[b()]=0 end,inc=function(y)local z=b()y.coro[z]=y.coro[z]+1;return y:at(y.coro[z]),y.coro[z]end,frz=function(y)if y.fi then if y.fi~=#y.stk then return error('Variadic accumulation has been detected during composition. Make sure that you are not conditionally invoking hooks (for instance, within an if statement).',2)end end;y.fi=#y.stk end,at=function(y,A)return y.stk[A]end,set=function(y,A,B)y.stk[A]=B end,add=function(y,B)y.stk[#y.stk+1]=B;return B end}end;local C={'obj','st','efc','unm','evt','trs','anm','sbc','sub'}local function D(E)local F=b()m[F]=E;return m[F]end;local function G()return m[b()]end;local function H(I,J,K)local L=G()D(I)local M={J()}D(L)return K and unpack(M)end;local function N(O)local P=G()return P.opts[O]or P.opts['enableAll']or error('"'..O..'" is not enabled in this component builder.')end;local Q;do local function R(S,T)local U=a(S)=='Instance'and S or e(S)for t,u in next,T do if a(t)=='number'then u().Parent=U else local q=a(u)=='table'and c(u)if q and q.tt=='Subscription'then U[t]=u.value else U[t]=u end end end;return U end;function Q(S,T)assert(e,'Instance creation is not supported.')local I=G()local V=I.obj:inc()if not V then T=T or{}V=R(S,T)I.obj:add(V)g(V.Destroying,function()for W,X in next,I.unm.stk do X()end end)end;for W,Y in next,I.evt.stk do Y.connection=g(V[Y.name],Y.fn)end;return V end end;local function Z(_,a0,a1,a2)assert(f,'Tweening is not supported.')local a3;local function a4(a5)a3=a5 end;local a6=f:Create(_,TweenInfo.new(a2.fn(a1,a4)),{[a0]=a1})if a3 then g(a6.Completed,a3)end;a6:Play()return true end;local function a7(a8,a9)for t,u in next,a9 do if a(t)~='number'then local I=G()local aa,ab=a(a8[t]),a(u)if ab=='table'then local ac=c(u)if ac and ac.tt then if ac.tt=='Subscription'then u.represents.listeners[t]=function(ad)a8[t]=ad end;a8[t]=u.value end else a8[t]=u end elseif aa~=ab then a8[t]=u elseif I.ani[t]then for W,B in next,I.anm.stk do if B.name==t then Z(a8,t,I.ani[t],B)end end elseif a8[t]~=u then local ae={}for W,B in next,I.trs.stk do if B.name==t then ae[t]=Z(a8,t,u,B)end end;if not ae[t]then a8[t]=u end end else u()end end;return a8 end;function i.useState(o)local I=G()local V,A=I.st:inc()if V then return V.value,V.updater else local af;af=I.st:add({value=o,updater=function(ad)if I.st:at(A).value~=ad then af.value=ad;I.render()end end})return af.value,af.updater end end;function i.useEffect(J,ag)local I=G()local V=I.efc:inc()if not V then I.efc:add({fn=J,states=ag or{}})elseif ag then for A=1,#ag do if V.st[A]~=ag[A]then V.fn()break end end end end;function i.useEvent(ah,ai)N('useEvent')local I=G()local V=I.evt:inc()if V then h(V.connection)V.connection=nil;V.fn=ai else I.evt:add({name=ah,fn=ai})end end;function i.useTransition(aj,ak)N('useTransition')local I=G()local V=I.trs:inc()if not V then I.trs:add({name=aj,fn=ak})end end;function i.useAnimation(aj,ak)N('useAnimation')local I=G()return I.anm:inc()or I.anm:add({name=aj,fn=ak,perform=function(ad)I.ani[aj]=ad end}).perform end;local al={tt='Subscription',__call=function(q,am)return am and q.represents.updater(am)or q.value end}function i.useSubscription(o)N('useSubscription')local I=G()local V,A=I.sub:inc()if V then return V.proxy,V.updater else local an={listeners={},value=o}an.proxy=d({value=o,represents=an},al)an.updater=function(ad)if I.sub:at(A).value~=ad then an.value=ad;an.proxy.value=ad;for W,ao in next,an.listeners do ao(ad)end end;return ad end;I.sub:add(an)return an.proxy,V.updater end end;function i.useTriggerableRender()return G().render end;function i.builder(ap,aq,ar)ar=ar or{}return function(as,at)return function(au)if not ar.hydration and at then return error('Hydration not enabled in builder options.')end;local av={opts=ar,prev=n(),props=au,ani={}}if G()then local aw=G()local V=aw.sbc:inc()if V then V.props=au;return V.render else aw.sbc:add(av)end end;for A=1,#C do av[C[A]]=x()end;av.render=coroutine.wrap(function()while true do coroutine.yield(H(av,function()for A=1,#C do av[C[A]]:rst()end;local S,ax=as(av.props)if a(S)~='string'or a(ax)~='table'then error('Component renderer must return a classname and properties.')end;for A=1,#C do local ay=C[A]if ay~='obj'then av[ay]:frz()end end;local U=ap(at or S,ax)aq(U,ax)if not av.prev.v or not av.prev.v and at then av.prev.v=U;for W,az in next,av.efc.stk do local X=az.fn()if X and not av.unm:inc()then av.unm:add(X)end end end;if ar.useAnimation then av.ani={}end;return U end,true))end end)return av.render end end end;local aA=i.builder(Q,a7,{enableAll=true})function i.component(as)return aA(as)end;local aB=i.builder(Q,a7,{hydration=true,enableAll=true})function i.hydrate(aC,as,au)aB(as,aC)(au)()end;return i