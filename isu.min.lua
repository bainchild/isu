local a=assert;local b=typeof or type;local c=coroutine.running;local d=table.unpack or unpack;local e=next;local f=getmetatable;local g=setmetatable;local h=Instance and Instance.new;local i=game and game:GetService("TweenService")local j=game.Destroying.Connect;local k=j(game.Destroying,function()end).Disconnect;local l={}local m={__mode='k'}local n={__mode='v'}local o={__mode='kv'}local p=g({},m)local function q(r)return g({v=r},n)end;local function s(t,u)local v={}for w,x in e,t do v[w]=b(x)=='table'and u and s(x,u)or x end;return v end;local function y()return{stk={},coro=g({},o),rst=function(z)z.coro[c()]=0 end,inc=function(z)local A=c()z.coro[A]=z.coro[A]+1;return z:at(z.coro[A]),z.coro[A]end,frz=function(z)a(not z.fi or z.fi==#z.stk,'Variadic accumulation has been detected during composition. Make sure that you are not conditionally invoking hooks')z.fi=#z.stk end,at=function(z,B)return z.stk[B]end,set=function(z,B,C)z.stk[B]=C end,add=function(z,C)z.stk[#z.stk+1]=C;return C end}end;local D={'obj','st','efc','unm','evt','trs','anm','sbc','sub'}local function E(F)local G=c()p[G]=F;return p[G]end;local function H()return p[c()]end;local function I(J,K)local L=H()E(J)local M=K()E(L)return M end;local function N(O)local P=H()a(P.opts[O]or P.opts.all,'"'..O..'" is not enabled in this component builder')end;local Q;do local function R(S,T)local U=b(S)=='Instance'and S or h(S)for w,x in e,T do if b(w)=='number'then x().Parent=U else local t=b(x)=='table'and f(x)if t and t.tt=='Subscription'then U[w]=x.value else U[w]=x end end end;return U end;function Q(S,T)a(h,'Instance creation is not supported.')local J=H()local V=J.obj:inc()if not V then T=T or{}V=R(S,T)J.obj:add(V)j(V.Destroying,function()for W,X in e,J.unm.stk do X()end end)end;for W,Y in e,J.evt.stk do Y.connection=j(V[Y.name],Y.fn)end;return V end end;local function Z(_,a0,a1,a2)a(i,'Tweening is not supported.')local a3;local function a4(a5)a3=a5 end;local a6=i:Create(_,TweenInfo.new(a2.fn(a1,a4)),{[a0]=a1})if a3 then j(a6.Completed,a3)end;a6:Play()return true end;local function a7(a8,a9)for w,x in e,a9 do if b(w)~='number'then local J=H()local aa,ab=b(a8[w]),b(x)if ab=='table'then local ac=f(x)if ac and ac.tt then if ac.tt=='Subscription'then x.represents.listeners[w]=function(ad)a8[w]=ad end;a8[w]=x.value end else a8[w]=x end elseif aa~=ab then a8[w]=x elseif J.ani[w]then for W,C in e,J.anm.stk do if C.name==w then Z(a8,w,J.ani[w],C)end end elseif a8[w]~=x then local ae={}for W,C in e,J.trs.stk do if C.name==w then ae[w]=Z(a8,w,x,C)end end;if not ae[w]then a8[w]=x end end else x()end end;return a8 end;function l.useState(r)local J=H()local V,B=J.st:inc()if V then return V.value,V.updater else local af;af=J.st:add({value=r,updater=function(ad)if J.st:at(B).value~=ad then af.value=ad;J.render()end end})return af.value,af.updater end end;function l.useEffect(K,ag)local J=H()local V=J.efc:inc()if not V then J.efc:add({fn=K,states=ag or{}})elseif ag then for B=1,#ag do if V.st[B]~=ag[B]then V.fn()break end end end end;function l.useEvent(ah,ai)N('useEvent')local J=H()local V=J.evt:inc()if V then k(V.connection)V.connection=nil;V.fn=ai else J.evt:add({name=ah,fn=ai})end end;function l.useTransition(aj,ak)N('useTransition')local J=H()local V=J.trs:inc()if not V then J.trs:add({name=aj,fn=ak})end end;function l.useAnimation(aj,ak)N('useAnimation')local J=H()return J.anm:inc()or J.anm:add({name=aj,fn=ak,perform=function(ad)J.ani[aj]=ad end}).perform end;local al={tt='Subscription',__call=function(t,am)return am and t.represents.updater(am)or t.value end}function l.useSubscription(r)N('useSubscription')local J=H()local V,B=J.sub:inc()if V then return V.proxy,V.updater else local an={listeners={},value=r}an.proxy=g({value=r,represents=an},al)an.updater=function(ad)if J.sub:at(B).value~=ad then an.value=ad;an.proxy.value=ad;for W,ao in e,an.listeners do ao(ad)end end;return ad end;J.sub:add(an)return an.proxy,V.updater end end;function l.useTriggerableRender()return H().render end;function l.builder(ap,aq,ar)ar=ar or{}return function(as,at)return function(au)a(not ar.hydration or at,'Hydration requires object parameter.')local av={opts=ar,prev=q(),props=au,ani={}}if H()then local aw=H()local V=aw.sbc:inc()if V then V.props=au;return V.render else aw.sbc:add(av)end end;for B=1,#D do av[D[B]]=y()end;av.render=coroutine.wrap(function()while true do coroutine.yield(I(av,function()for B=1,#D do av[D[B]]:rst()end;local S,ax=as(av.props)a(b(S)=='string'and b(ax)=='table','Fenderer must return a classname and properties')for B=1,#D do local ay=D[B]if ay~='obj'then av[ay]:frz()end end;local U=ap(at or S,ax)aq(U,ax)if not av.prev.v or not av.prev.v and at then av.prev.v=U;for W,az in e,av.efc.stk do local X=az.fn()if X and not av.unm:inc()then av.unm:add(X)end end end;if ar.useAnimation then av.ani={}end;return U end))end end)return av.render end end end;local aA=l.builder(Q,a7,{all=true})function l.component(as)return aA(as)end;local aB=l.builder(Q,a7,{hydration=true,all=true})function l.hydrate(aC,as,au)aB(as,aC)(au)()end;return l